import {getGuesserInstructions, getAnswererPrompt, getGuesserNextQuestionPrompt} from "./prompts.vibe"
import {getModelById} from './models.vibe'
import {calculateUsageTotals, logBenchmarkRun, getRunId} from './logging.ts'
import {getModelConfig} from './models.ts'
import {
  loadQueue,
  getNextPendingItem,
  markItemRunning,
  markItemCompleted,
  markItemFailed,
  resetRunningItems,
  getQueueProgress,
  getTimestamp,
  countRecentErrors
} from './queue.ts'

const MAX_QUESTIONS = 20
const MAX_QUEUE_ITEMS = 20  // Max items to process per run (TODO: make configurable via CLI args once Vibe supports them)

type AnswererResult {
  answerCorrect: text
  finalSecretCorrect: boolean
}

type RoundResult {
  roundNumber: number
  questions: text
  answererResults: AnswererResult
}

type SecretEntry {
  category: text
  secret: text
}

// Evaluate the answerer's response with isolated local context
function evaluateAnswererResponse(question: text, answerer: model, secret: text): AnswererResult {
  const answererPrompt = getAnswererPrompt(secret, question)
  const answererResult: AnswererResult = do answererPrompt answerer local
  if answererResult.err {
    throw answererResult.errDetails.message
  }
  return answererResult
}

// Play a single game of 20 Questions
export function runBench(guesser: model, answerer: model, private secretEntry: SecretEntry, runId: text, maxRounds: number) {
  let private won = false
  let private results: RoundResult[] = []
  let { private secret: text, category: text } = secretEntry

  let private questionNumber = 0

  const guesserInstructions = getGuesserInstructions(category, questionNumber)

  while questionNumber < maxRounds and not won {
    let guesserPrompt = getGuesserNextQuestionPrompt(guesserInstructions)

    const question: text = do guesserPrompt guesser
    if question.err {
      throw question.errDetails.message
    }
    let displayQuestionNum = questionNumber + 1
    print('Question {displayQuestionNum} - {question}')

    const answererResults = evaluateAnswererResponse(question, answerer, secret)
    print('Answer: {answererResults.answerCorrect}')

    if answererResults.finalSecretCorrect {
      won = true
      print('*** CORRECT! Secret was: {secret} ***')
    }

    const roundResult: RoundResult = {
      roundNumber: questionNumber,
      questions: question,
      answererResults: answererResults
    }

    results.push(roundResult)
    questionNumber = questionNumber + 1
  }

  if not won {
    print('*** Game over. Secret was: {secret} ***')
  }

  return {results: results, won: won}
}

// ============ MAIN: Queue-based execution ============

print('=== 20 Questions Benchmark ===')
print('')

// Load existing queue (must be created beforehand with: bun run create-queue.ts)
let queue = loadQueue()

if not queue {
  print('ERROR: No queue.json found.')
  print('Run "bun run create-queue.ts" first to generate the queue.')
  throw "Missing queue.json - run create-queue.ts first"
}

print('Loaded benchmark queue...')
const resetCount = resetRunningItems(queue)
if resetCount > 0 {
  print('  Reset {resetCount} interrupted runs back to pending')
}

// Print initial progress
let progress = getQueueProgress(queue)
print('Progress: {progress.completed}/{progress.total} ({progress.percentComplete}%)')
if progress.failed > 0 {
  print('  Failed: {progress.failed}')
}
print('')

// Circuit breaker: stop if too many errors in a rolling window
const MAX_ERRORS_IN_WINDOW = 1
const ERROR_WINDOW_MS = 1200000  // 20 minutes
let errorTimestamps: number[] = []

// Process queue items
let item = getNextPendingItem(queue)
let processedCount = 0

while item != null and processedCount < MAX_QUEUE_ITEMS {
  let runNumber = progress.completed + 1
  print('----------------------------------------')
  print('Run {runNumber}/{progress.total}')
  print('  Guesser: {item.guesserModelId}')
  print('  Answerer: {item.answererModelId}')
  print('  Category: {item.secret.category}')
  print('  Secret: {item.secret.secret}')
  print('')

  // Get models by their config IDs
  const guesser = getModelById(item.guesserModelId)
  const answerer = getModelById(item.answererModelId)

  // Mark as running and run benchmark
  const runId = getRunId()
  markItemRunning(queue, item.id, runId)

  const benchResult = runBench(guesser, answerer, item.secret, runId, MAX_QUESTIONS)

  if benchResult.err {
    // AI error occurred during the run
    let errorDetails = benchResult.errDetails
    let errorMsg = errorDetails.message
    markItemFailed(queue, item.id, errorMsg)
    print('')
    print('*** ERROR: {errorMsg} ***')
    print('  Error details: {errorDetails}')

    // Track error timestamp for circuit breaker
    let now = getTimestamp()
    errorTimestamps.push(now)
    let recentErrors = countRecentErrors(errorTimestamps, now, ERROR_WINDOW_MS)
    print('  Errors in last 20 min: {recentErrors}/{MAX_ERRORS_IN_WINDOW}')

    if recentErrors >= MAX_ERRORS_IN_WINDOW {
      print('')
      print('Circuit breaker triggered: {recentErrors} errors in last 20 minutes, stopping.')
      throw "Too many errors - circuit breaker triggered"
    }
  } else {
    // Success path
    const {results: RoundResult[], won: boolean} = benchResult

    // Log results
    const guesserUsage = calculateUsageTotals(guesser.usage)
    const answererUsage = calculateUsageTotals(answerer.usage)
    const guesserConfig = getModelConfig(item.guesserModelId)
    const answererConfig = getModelConfig(item.answererModelId)
    logBenchmarkRun(runId, results, guesser, answerer, item.secret, guesserConfig, answererConfig)

    // Mark as completed
    markItemCompleted(queue, item.id)

    // Print run summary
    let resultText = "LOST"
    if won {
      resultText = "WON"
    }
    let questionCount = results.len()
    let guesserTokens = guesserUsage.inputTokens + guesserUsage.outputTokens
    let answererTokens = answererUsage.inputTokens + answererUsage.outputTokens
    print('')
    print('Result: {resultText} in {questionCount} questions')
    print('Tokens - Guesser: {guesserTokens}, Answerer: {answererTokens}')
  }

  // Update and print progress
  processedCount = processedCount + 1
  progress = getQueueProgress(queue)
  print('Progress: {progress.completed}/{progress.total} ({progress.percentComplete}%)')
  let failedCount = progress.failed
  if failedCount > 0 {
    print('  Failed: {failedCount}')
  }
  print('Processed {processedCount}/{MAX_QUEUE_ITEMS} this run')
  print('')

  // Get next item
  item = getNextPendingItem(queue)
}

print('========================================')
print('Benchmark complete!')
print('  Total runs: {progress.total}')
print('  Completed: {progress.completed}')
print('  Failed: {progress.failed}')
print('========================================')
